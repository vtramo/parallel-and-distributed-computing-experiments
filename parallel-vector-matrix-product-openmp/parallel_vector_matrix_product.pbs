#!/bin/bash

#PBS -q studenti
#PBS -l nodes=1:ppn=8
#PBS â€“N parallel_vector_matrix_product
#PBS -o parallel_vector_matrix_product.out
#PBS -e parallel_vector_matrix_product.err

echo 'Job is running on node(s): '
cat $PBS_NODEFILE

PBS_O_WORKDIR=$PBS_O_HOME/parallel-vector-matrix-product-openmp
echo ------------------------------------------------------
echo PBS: qsub is running on $PBS_O_HOST
echo PBS: originating queue is $PBS_O_QUEUE
echo PBS: executing queue is $PBS_QUEUE
echo PBS: working directory is $PBS_O_WORKDIR
echo PBS: execution mode is $PBS_ENVIRONMENT
echo PBS: job identifier is $PBS_JOBID
echo PBS: job name is $PBS_JOBNAME
echo PBS: node file is $PBS_NODEFILE
echo PBS: current home directory is $PBS_O_HOME
echo PBS: PATH = $PBS_O_PATH
echo ------------------------------------------------------

# Questo PBS deve essere avviato tramite lo script "start_parallel_vector_matrix_product_pbs.sh"

FILENAME_VECTOR_VALUES="$PBS_O_WORKDIR/vector_values.txt"
FILENAME_MATRIX_VALUES="$PBS_O_WORKDIR/matrix_values.txt"
FILENAME_RESULTS="$PBS_O_WORKDIR/results.txt"
TOT_ITERATIONS=5

result_parallel_vector_matrix_product=""
result_single_thread_vector_matrix_product=""
time_parallel_vector_matrix_product=0
time_single_thread_vector_matrix_product=0

function execute_parallel_vector_matrix_product() {
    export OMP_NUM_THREADS=$total_threads
    export PSC_OMP_AFFINITY=TRUE
    gcc -fopenmp -lgomp -o $PBS_O_WORKDIR/parallel_vector_matrix_product $PBS_O_WORKDIR/parallel_vector_matrix_product.c

    for ((i = 0; i < $TOT_ITERATIONS; i++)); do
        result_parallel_vector_matrix_product=$($PBS_O_WORKDIR/parallel_vector_matrix_product $rows $columns $FILENAME_MATRIX_VALUES $FILENAME_VECTOR_VALUES $printing_mode)
        this_time=$(echo "$result_parallel_vector_matrix_product" | grep "TIME" | awk '{print $4}')
        time_parallel_vector_matrix_product=$(awk -v a="$this_time" -v b="$time_parallel_vector_matrix_product" 'BEGIN{print (a + b)}')
    done

    time_parallel_vector_matrix_product=$(awk -v a="$time_parallel_vector_matrix_product" -v b="$TOT_ITERATIONS" 'BEGIN{print (a / b)}')
    echo "$result_parallel_vector_matrix_product"
    rm $PBS_O_WORKDIR/parallel_vector_matrix_product
}

function execute_single_thread_vector_matrix_product() {
    gcc -o $PBS_O_WORKDIR/single_thread_vector_matrix_product $PBS_O_WORKDIR/single_thread_vector_matrix_product.c

    for ((i = 0; i < $TOT_ITERATIONS; i++)); do
        result_single_thread_vector_matrix_product=$($PBS_O_WORKDIR/single_thread_vector_matrix_product $rows $columns $FILENAME_MATRIX_VALUES $FILENAME_VECTOR_VALUES)
        this_time=$(echo "$result_single_thread_vector_matrix_product" | grep "TIME" | awk '{print $5}')
        time_single_thread_vector_matrix_product=$(awk -v a="$this_time" -v b="$time_single_thread_vector_matrix_product" 'BEGIN{print (a + b)}')
    done

    time_single_thread_vector_matrix_product=$(awk -v a="$time_single_thread_vector_matrix_product" -v b="$TOT_ITERATIONS" 'BEGIN{print (a / b)}')
    echo "$result_single_thread_vector_matrix_product"
    rm $PBS_O_WORKDIR/single_thread_vector_matrix_product
}

execute_single_thread_vector_matrix_product
execute_parallel_vector_matrix_product

rm $FILENAME_VECTOR_VALUES
rm $FILENAME_MATRIX_VALUES

if [[ ! -e "$FILENAME_RESULTS" ]]; then
    printf "PARALLEL_TIME\tSINGLETH_TIME\tSPEED_UP_P/ST\tTOTAL_THREADS\tROWS\tCOLUMNS\tTOT_NUMBERS\tTOT_ITERATIONS" > $FILENAME_RESULTS
fi

speed_up=$(awk -v a="$time_single_thread_vector_matrix_product" -v b="$time_parallel_vector_matrix_product" 'BEGIN{print (a / b)}')
printf "\n$time_parallel_vector_matrix_product\t$time_single_thread_vector_matrix_product\t$speed_up\t$OMP_NUM_THREADS\t$rows\t$columns\t$(($rows * $columns))\t$TOT_ITERATIONS" >> $FILENAME_RESULTS